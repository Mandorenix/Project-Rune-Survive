## Grundlig Kodanalys & F√∂rb√§ttringsplan

Efter att ha g√•tt igenom din kod i detalj har jag identifierat flera kritiska omr√•den. H√§r √§r en fullst√§ndig plan med prioriterade √•tg√§rder:

### üö® Kritisk √Ötg√§rd (Omedelbar implementation)
1. **Ljudsystemets tr√•dhantering**
   - Problem: Blockering i huvudloopen n√§r ljudkrock intr√§ffar
   - L√∂sning: Implementera ljudk√∂ med dedikerad tr√•d
   - Fil: `src/Audio/SoundManager.cpp`

```cpp
// Uppdaterad SoundManager
void SoundManager::init() {
    // Allokera fler ljudkanaler
    Mix_AllocateChannels(32);
    
    // Starta ljudtr√•d
    soundThread = SDL_CreateThread(soundThreadFunction, "SoundThread", nullptr);
}

int SoundManager::soundThreadFunction(void* data) {
    while (true) {
        std::string nextSound = "";
        {
            std::lock_guard<std::mutex> lock(queueMutex);
            if (!soundQueue.empty()) {
                nextSound = soundQueue.front();
                soundQueue.pop();
            }
        }
        
        if (!nextSound.empty()) {
            Mix_Chunk* sound = ResourceManager::getSound(nextSound);
            if (sound) {
                int channel = Mix_PlayChannel(-1, sound, 0);
                if (channel == -1) {
                    SDL_Log("Ljudspelning misslyckades: %s", Mix_GetError());
                }
            }
        }
        SDL_Delay(5); // Minska CPU-belastning
    }
    return 0;
}
```

### ‚ö° Prestandaoptimeringar
2. **Rendering Optimering**
   - Problem: Texturer h√§mtas varje frame
   - L√∂sning: Cacha textur-referenser
   - Fil: `src/Game.cpp`

```cpp
void Game::render() {
    // F√∂rbered texturer EN g√•ng
    static SDL_Texture* playerTex = ResourceManager::getTexture("player");
    static SDL_Texture* enemyTex = ResourceManager::getTexture("enemy");
    
    for (auto& entity : entities) {
        SDL_Texture* tex = nullptr;
        switch(entity.getType()) {
            case EntityType::PLAYER: tex = playerTex; break;
            case EntityType::ENEMY: tex = enemyTex; break;
            // ... andra entitetstyper
        }
        SDL_RenderCopy(renderer, tex, nullptr, &entity.getRect());
    }
}
```

3. **Kollisionsoptimering**
   - Problem: O(n¬≤) komplexitet
   - L√∂sning: Spatial grid-system
   - Fil: `src/Physics/Physics.cpp`

```cpp
void Physics::update(std::vector<Entity>& entities) {
    // Skapa spatial grid
    std::unordered_map<std::pair<int, int>, std::vector<Entity*>> grid;
    const int GRID_SIZE = 100; // Justera baserat p√• spelf√∂nsterstorlek

    // Fyll griden
    for (auto& entity : entities) {
        int gridX = static_cast<int>(entity.x) / GRID_SIZE;
        int gridY = static_cast<int>(entity.y) / GRID_SIZE;
        grid[{gridX, gridY}].push_back(&entity);
    }

    // Kolla kollisioner per grid-cell
    for (auto& cell : grid) {
        auto& entitiesInCell = cell.second;
        for (size_t i = 0; i < entitiesInCell.size(); ++i) {
            for (size_t j = i + 1; j < entitiesInCell.size(); ++j) {
                if (checkCollision(*entitiesInCell[i], *entitiesInCell[j])) {
                    // Hantera kollision
                }
            }
        }
    }
}
```

### üêû Buggfixar
4. **Minnesl√§ckor**
   - Problem: Resurser frig√∂rs inte
   - Fil: `src/Core/ResourceManager.cpp`

```cpp
void ResourceManager::cleanup() {
    // Texturer
    for (auto& tex : textures) {
        SDL_DestroyTexture(tex.second);
    }
    textures.clear();

    // Ljud
    for (auto& sound : sounds) {
        Mix_FreeChunk(sound.second);
    }
    sounds.clear();

    // Fonts
    for (auto& font : fonts) {
        TTF_CloseFont(font.second);
    }
    fonts.clear();
}
```

5. **Entitetshantering**
   - Problem: D√∂da entiteter tas inte bort
   - Fil: `src/Game.cpp`

```cpp
void Game::update() {
    // Ta bort d√∂da entiteter
    entities.erase(std::remove_if(entities.begin(), entities.end(),
        [](const Entity& e) { return e.isDead(); }),
        entities.end());
}
```

6. **FPS-reglering**
   - Problem: Ingen FPS-begr√§nsning
   - Fil: `src/main.cpp`

```cpp
const int TARGET_FPS = 60;
const int FRAME_DELAY = 1000 / TARGET_FPS;

Uint32 frameStart;
int frameTime;

while (running) {
    frameStart = SDL_GetTicks();
    
    // Huvudloop-logik
    
    frameTime = SDL_GetTicks() - frameStart;
    if (FRAME_DELAY > frameTime) {
        SDL_Delay(FRAME_DELAY - frameTime);
    }
}
```

### üõ†Ô∏è Refaktorering & Strukturf√∂rb√§ttringar
7. **Inputhantering**
   - Problem: Musinput hanteras inkonsekvent
   - L√∂sning: Centraliserad inputhanterare
   - Fil: `src/Input/InputHandler.cpp`

```cpp
void InputHandler::update() {
    SDL_Event event;
    while (SDL_PollEvent(&event)) {
        switch (event.type) {
            case SDL_MOUSEBUTTONDOWN:
                mouseDown = true;
                SDL_GetMouseState(&mouseX, &mouseY);
                break;
            case SDL_MOUSEBUTTONUP:
                mouseDown = false;
                break;
            // Hantera andra h√§ndelser
        }
    }
}
```

8. **Resursladdning**
   - Problem: Ljud laddas n√§r de spelas
   - L√∂sning: F√∂rladdning vid start
   - Fil: `src/main.cpp`

```cpp
// Innan huvudloopen
ResourceManager::loadSound("shoot", "assets/sounds/shoot.wav");
ResourceManager::loadSound("explosion", "assets/sounds/explosion.wav");
// ... andra ljud
```

### üìã Implementeringsplan (Prioriterad ordning)

| Prioritet | Omr√•de             | √Ötg√§rd                             | Tidsuppskattning |
|-----------|--------------------|-----------------------------------|------------------|
| KRITISKT  | Ljudsystem         | Implementera tr√•dad ljudk√∂         | 2 timmar         |
| H√ñG       | Prestanda          | Inf√∂r spatial grid f√∂r kollisioner | 3 timmar         |
| H√ñG       | Minne              | Fixa minnesl√§ckor                  | 1 timmar         |
| MEDIUM    | Rendering          | Cacha textur-referenser            | 1 timmar         |
| MEDIUM    | Spelmotor          | Implementera FPS-reglering         | 30 minuter       |
| L√ÖG       | Refaktorering      | Inputhanterare                     | 2 timmar         |

### üí° Ytterligare F√∂rb√§ttringar
- **Profilering**: Anv√§nd `SDL_GetPerformanceCounter()` f√∂r att identifiera flaskhalsar
- **Resursmonitor**: Implementera debug-visning f√∂r antal entiteter/ljud
- **Ljudprioritering**: L√§gg till system f√∂r att avbryta mindre viktiga ljud
- **Effektiv s√∂kning**: Implementera spatial hash-map f√∂r snabbare kollisioner

### ‚úÖ Testplan
1. **Ljudtest**: Spela upp 20+ ljud samtidigt
2. **Prestandatest**: Skapa 1000+ entiteter och m√§ta FPS
3. **Minnestest**: K√∂ra spelet l√§ngre tid och kontrollera minnesanv√§ndning
4. **Kollisionstest**: Testa med m√•nga objekt i samma omr√•de

Genom att implementera dessa √•tg√§rder kommer spelet att bli betydligt mer stabilt och prestandam√§ssigt effektivt. B√∂rja med de kritiska ljud- och minnesfixarna, sedan prestandaoptimeringarna.