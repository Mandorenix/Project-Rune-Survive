# Projekt Rune Survive: Optimering & F√∂rb√§ttringsplan

## üöÄ Kritisk F√∂rb√§ttringar med Detaljerade F√∂rklaringar

### 1. **Ljudhanterare med Web Audio API**
**Problem**: Ljudkonflikter orsakar fryser n√§r m√•nga ljud spelas samtidigt  
**L√∂sning**: Kanalhantering med k√∂system f√∂r att undvika √∂verbelastning

```javascript
class AudioManager {
  constructor() {
    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
    this.sounds = {};
    this.maxChannels = 8; // Begr√§nsa antalet samtidiga ljud
    this.channels = Array(this.maxChannels).fill(null);
    this.queue = [];
  }

  async loadSound(name, url) {
    const response = await fetch(url);
    const arrayBuffer = await response.arrayBuffer();
    this.sounds[name] = await this.audioContext.decodeAudioData(arrayBuffer);
  }

  playSound(name) {
    if (!this.sounds[name]) {
      console.warn(`Ljud '${name}' inte laddat!`);
      return;
    }
    
    // K√∂hantering vid full belastning
    if (this.queue.length > 10) {
      console.warn(`Ljudk√∂ full (${this.queue.length}), ignorerar ${name}`);
      return;
    }
    
    const availableChannel = this.channels.findIndex(ch => !ch || ch.playState === 'finished');
    
    if (availableChannel !== -1) {
      this._playInChannel(name, availableChannel);
    } else {
      this.queue.push(name);
      console.log(`Ljud k√∂at: ${name} (k√∂storlek: ${this.queue.length})`);
    }
  }

  _playInChannel(name, channelIndex) {
    const source = this.audioContext.createBufferSource();
    source.buffer = this.sounds[name];
    source.connect(this.audioContext.destination);
    source.start(0);
    
    // Hantera n√§r ljudet √§r klart
    source.onended = () => {
      this.channels[channelIndex] = null;
      // Spela n√§sta ljud i k√∂n om det finns
      if (this.queue.length > 0) {
        const nextSound = this.queue.shift();
        console.log(`Spelar k√∂at ljud: ${nextSound}`);
        this._playInChannel(nextSound, channelIndex);
      }
    };
    
    // Uppdatera kanalstatus
    this.channels[channelIndex] = {
      source,
      playState: 'playing',
      name: name,
      startTime: performance.now()
    };
  }
}
```

**Varf√∂r detta √§r viktigt**:  
- **Kanalbegr√§nsning** f√∂rhindrar att f√∂r m√•nga ljud spelas samtidigt, vilket √§r en vanlig orsak till fryser
- **K√∂hantering** s√§kerst√§ller att ljud inte tappas bort vid h√∂g belastning
- **Automatisk kanal√•teranv√§ndning** optimerar resursanv√§ndning
- **Felhantering** f√∂rhindrar att missade ljud kraschar spelet

### 2. **Canvas-rendering med Offscreen Buffer**
**Problem**: L√•g FPS vid m√•nga objekt p√• sk√§rmen  
**L√∂sning**: Anv√§nd offscreen-canvas f√∂r batch-rendering

```javascript
class GameRenderer {
  constructor(mainCanvas) {
    this.mainCanvas = mainCanvas;
    this.mainCtx = mainCanvas.getContext('2d');
    
    // Skapa dold canvas f√∂r rendering
    this.offscreenCanvas = document.createElement('canvas');
    this.offscreenCanvas.width = mainCanvas.width;
    this.offscreenCanvas.height = mainCanvas.height;
    this.offscreenCtx = this.offscreenCanvas.getContext('2d');
    
    // Cacha vanliga operationer
    this.imageCache = new Map();
    this.lastRenderTime = 0;
    this.renderStats = {
      totalFrames: 0,
      averageFPS: 0
    };
  }

  preloadImage(key, url) {
    return new Promise((resolve) => {
      const img = new Image();
      img.onload = () => {
        this.imageCache.set(key, img);
        resolve();
      };
      img.src = url;
    });
  }

  render(entities) {
    const startTime = performance.now();
    
    // Rensa offscreen-canvas
    this.offscreenCtx.clearRect(0, 0, 
      this.offscreenCanvas.width, 
      this.offscreenCanvas.height
    );
    
    // Rendera bakgrund f√∂rst
    this.offscreenCtx.fillStyle = '#202030';
    this.offscreenCtx.fillRect(
      0, 0, 
      this.offscreenCanvas.width, 
      this.offscreenCanvas.height
    );
    
    // Batch-rendera entiteter
    entities.forEach(entity => {
      const img = this.imageCache.get(entity.spriteKey);
      if (img) {
        this.offscreenCtx.drawImage(
          img,
          entity.x, entity.y,
          entity.width, entity.height
        );
      }
    });
    
    // Kopiera till huvudcanvas
    this.mainCtx.clearRect(0, 0, 
      this.mainCanvas.width, 
      this.mainCanvas.height
    );
    this.mainCtx.drawImage(this.offscreenCanvas, 0, 0);
    
    // Ber√§kna renderingsstatistik
    const renderTime = performance.now() - startTime;
    this.renderStats.totalFrames++;
    
    // Uppdatera FPS var 60:e frame
    if (this.renderStats.totalFrames % 60 === 0) {
      this.renderStats.averageFPS = Math.round(
        1000 / (startTime - this.lastRenderTime)
      );
    }
    this.lastRenderTime = startTime;
  }
}
```

**Varf√∂r detta √§r viktigt**:  
- **Offscreen-rendering** minskar flimmer och f√∂rb√§ttrar prestanda
- **Batch-rendering** minimerar kostnadsf√§llda canvas-operationer
- **Bildcachning** undviker upprepad laddning av resurser
- **Prestandamonitorering** ger insyn i renderingshastighet
- **Strukturering** separerar rendering fr√•n spellogik

### 3. **Kollisionshantering med Spatial Grid**
**Problem**: O(n¬≤) komplexitet g√∂r spelet l√•ngsamt vid m√•nga objekt  
**L√∂sning**: Spatial partitioning med dynamiskt rutn√§t

```javascript
class CollisionSystem {
  constructor(gridSize = 128) {
    this.gridSize = gridSize;
    this.grid = new Map();
    this.collisionStats = {
      checks: 0,
      collisions: 0,
      gridCells: 0
    };
  }

  update(entities) {
    this._buildGrid(entities);
    
    // Nollst√§ll statistik
    this.collisionStats.checks = 0;
    this.collisionStats.collisions = 0;
    this.collisionStats.gridCells = this.grid.size;
    
    // Kolla kollisioner per grid-cell
    for (const [key, cellEntities] of this.grid) {
      for (let i = 0; i < cellEntities.length; i++) {
        for (let j = i + 1; j < cellEntities.length; j++) {
          this.collisionStats.checks++;
          if (this._checkCollision(cellEntities[i], cellEntities[j])) {
            this.collisionStats.collisions++;
            this._handleCollision(cellEntities[i], cellEntities[j]);
          }
        }
      }
    }
  }

  _buildGrid(entities) {
    this.grid.clear();
    
    entities.forEach(entity => {
      if (!entity.collidable) return;
      
      // Ber√§kna grid-positioner
      const startX = Math.floor(entity.x / this.gridSize);
      const startY = Math.floor(entity.y / this.gridSize);
      const endX = Math.floor((entity.x + entity.width) / this.gridSize);
      const endY = Math.floor((entity.y + entity.height) / this.gridSize);
      
      // L√§gg till i relevanta celler
      for (let x = startX; x <= endX; x++) {
        for (let y = startY; y <= endY; y++) {
          const key = `${x},${y}`;
          if (!this.grid.has(key)) {
            this.grid.set(key, []);
          }
          this.grid.get(key).push(entity);
        }
      }
    });
  }

  _checkCollision(a, b) {
    return (
      a.x < b.x + b.width &&
      a.x + a.width > b.x &&
      a.y < b.y + b.height &&
      a.y + a.height > b.y
    );
  }

  _handleCollision(a, b) {
    // Skicka h√§ndelse till eventbuss
    eventBus.emit('collision', { entityA: a, entityB: b });
    
    // Standardkollisionshantering
    if (a.onCollision) a.onCollision(b);
    if (b.onCollision) b.onCollision(a);
  }
}
```

**Varf√∂r detta √§r viktigt**:  
- **Grid-baserad optimering** minskar O(n¬≤) till O(n) i praktiken
- **Dynamisk cellplacering** hanterar objekt som str√§cker sig √∂ver flera celler
- **Statistikinsamling** hj√§lper med prestandaoptimering
- **Flexibel kollisionshantering** via event-buss
- **Skalbarhet** fungerar bra √§ven med 1000+ entiteter

### 4. **FPS-reglerad Spelloop med Delta Time**
**Problem**: Oj√§mn uppdateringshastighet p√• olika maskiner  
**L√∂sning**: Tidsbaserad uppdatering med fasta tidssteg

```javascript
class GameLoop {
  constructor(updateFn, renderFn, fps = 60) {
    this.update = updateFn;
    this.render = renderFn;
    this.fps = fps;
    this.frameInterval = 1000 / fps;
    this.lastTime = 0;
    this.frameTime = 0;
    this.running = false;
    this.stats = {
      fps: 0,
      updateCount: 0,
      renderCount: 0
    };
  }

  start() {
    if (this.running) return;
    
    this.running = true;
    this.lastTime = performance.now();
    this._requestFrame();
  }

  stop() {
    this.running = false;
  }

  _requestFrame() {
    if (!this.running) return;
    requestAnimationFrame(this._run.bind(this));
  }

  _run(timestamp) {
    // Ber√§kna tidsdifferens
    const deltaTime = timestamp - this.lastTime;
    this.lastTime = timestamp;
    this.frameTime += deltaTime;

    // Uppdatera med fasta tidssteg
    while (this.frameTime >= this.frameInterval) {
      this.update(this.frameInterval / 1000); // Delta i sekunder
      this.stats.updateCount++;
      this.frameTime -= this.frameInterval;
    }
    
    // Rendera
    this.render();
    this.stats.renderCount++;
    
    // Ber√§kna FPS
    if (this.stats.renderCount % 60 === 0) {
      this.stats.fps = Math.round(1000 / deltaTime);
    }
    
    this._requestFrame();
  }
}

// Anv√§ndningsexempel
const gameLoop = new GameLoop(
  (deltaTime) => {
    // Uppdatera spellogik h√§r
    physicsSystem.update(deltaTime);
    entityManager.update(deltaTime);
  },
  () => {
    // Rendera spelet
    gameRenderer.render(entityManager.getEntities());
  },
  60 // M√•l-FPS
);

gameLoop.start();
```

**Varf√∂r detta √§r viktigt**:  
- **Konsekvent uppdatering** oavsett enhetens prestanda
- **Separation av uppdatering och rendering** f√∂r smidigare spelk√§nsla
- **FPS-oberoende fysik** f√∂r r√§ttvis spelupplevelse
- **Prestandamonitorering** inbyggd i loopen
- **Flexibel inst√§llning** av uppdateringshastighet

## üìÖ Implementeringsplan

### Vecka 1: Kritiska Prestandaf√∂rb√§ttringar
| Dag | Fokusomr√•de | Aktiviteter |
|-----|-------------|------------|
| 1   | Ljudsystem  | Implementera AudioManager med k√∂system |
| 2   | Rendering   | Integrera offscreen canvas och cachning |
| 3   | Kollision   | Bygg spatial grid-system |
| 4   | Spelloop    | Implementera delta-time baserad loop |
| 5   | Testning    | Prestandatest med 500+ entiteter |

### Vecka 2: Systemarkitektur & Resurshantering
| Dag | Fokusomr√•de | Aktiviteter |
|-----|-------------|------------|
| 1   | Event-buss  | Skapa central h√§ndelsehanterare |
| 2   | Resursladdning | Implementera AssetLoader med progressiv feedback |
| 3   | ECS         | B√∂rja migrera till Entity Component System |
| 4   | Debug       | Bygg prestandapanel med statistik |
| 5   | Integration | Kombinera alla system och testa |

### Vecka 3: Testning & Optimering
| Dag | Aktivitet | M√•l |
|-----|-----------|-----|
| 1   | Ljudtest | Simulera 100+ samtidiga ljudeffekter |
| 2   | Stress-test | K√∂ra med 1000+ entiteter |
| 3   | Minneshantering | Analysera med Chrome DevTools |
| 4   | Cross-browser | Testa i Firefox, Safari, Edge |
| 5   | Anv√§ndartest | Samla feedback fr√•n spelare |

## üß™ Teststrategi

### Prestandatestning
```javascript
// Testskript f√∂r att simulera h√∂g belastning
function runStressTest() {
  // Skapa 1000 testentiteter
  for (let i = 0; i < 1000; i++) {
    const entity = new Entity(
      Math.random() * canvas.width,
      Math.random() * canvas.height,
      20, 20
    );
    entity.velocity = {
      x: (Math.random() - 0.5) * 100,
      y: (Math.random() - 0.5) * 100
    };
    entityManager.add(entity);
  }
  
  // Spela ljud varje frame
  setInterval(() => {
    audioManager.playSound('explosion');
  }, 50);
  
  // Logga prestanda var 5:e sekund
  setInterval(() => {
    console.log(`FPS: ${gameLoop.stats.fps}`);
    console.log(`Entiteter: ${entityManager.count()}`);
    console.log(`Kollisionskontroller: ${collisionSystem.collisionStats.checks}`);
    console.log(`Ljudk√∂: ${audioManager.queue.length}`);
  }, 5000);
}
```

### Testscenarier
1. **Ljudintensivt scenario**: 50+ samtidiga ljudeffekter
2. **Entitets√∂versv√§mning**: 1000+ r√∂rliga objekt p√• sk√§rmen
3. **L√•ngk√∂ringstest**: L√•ta spelet k√∂ras i 1 timme
4. **Minnestest**: J√§mf√∂r minnesanv√§ndning f√∂re/efter optimering
5. **Kollisionstest**: M√•nga objekt i koncentrerade omr√•den

## ‚úÖ F√∂rv√§ntade Resultat
- **+300%** FPS-√∂kning vid h√∂g belastning
- **-90%** minskad ljudrelaterade fryser
- **+500%** fler entiteter utan prestandaf√∂rlust
- **Stabilare** spelupplevelse p√• olika enheter
- **L√§ttare** att l√§gga till ny funktionalitet

Genom att implementera dessa f√∂rb√§ttringar kommer spelet att bli betydligt mer stabilt, responsivt och underh√•llbart. B√∂rja med ljudsystemet och renderingen f√∂r att omedelbart l√∂sa de mest kritiska prestandaproblemen!