# Utvecklingsplan för Project Rune-Survive

## 1. Pathfinding Implementering

### Mål: Implementera A* (A-star) pathfinding för fiender

**Steg:**
1. Skapa en ny fil `pathfinding.js`
2. Implementera A*-algoritmen:
   ```javascript
   // pathfinding.js
   class AStar {
     constructor(grid) {
       this.grid = grid;
     }

     heuristic(a, b) {
       return Math.abs(a.x - b.x) + Math.abs(a.y - b.y);
     }

     search(start, end) {
       const openSet = [start];
       const closedSet = [];
       start.g = 0;
       start.f = this.heuristic(start, end);

       while (openSet.length > 0) {
         let lowestIndex = 0;
         for (let i = 0; i < openSet.length; i++) {
           if (openSet[i].f < openSet[lowestIndex].f) {
             lowestIndex = i;
           }
         }
         const current = openSet[lowestIndex];

         if (current.x === end.x && current.y === end.y) {
           let path = [];
           let temp = current;
           while (temp.parent) {
             path.push(temp);
             temp = temp.parent;
           }
           return path.reverse();
         }

         openSet.splice(lowestIndex, 1);
         closedSet.push(current);

         const neighbors = this.getNeighbors(current);
         for (const neighbor of neighbors) {
           if (closedSet.includes(neighbor)) continue;

           const gScore = current.g + 1;
           let gBest = false;

           if (!openSet.includes(neighbor)) {
             gBest = true;
             neighbor.h = this.heuristic(neighbor, end);
             openSet.push(neighbor);
           } else if (gScore < neighbor.g) {
             gBest = true;
           }

           if (gBest) {
             neighbor.parent = current;
             neighbor.g = gScore;
             neighbor.f = neighbor.g + neighbor.h;
           }
         }
       }
       return [];
     }

     getNeighbors(node) {
       const neighbors = [];
       const directions = [
         {x: 0, y: -1}, {x: 1, y: 0},
         {x: 0, y: 1}, {x: -1, y: 0}
       ];

       for (const dir of directions) {
         const x = node.x + dir.x;
         const y = node.y + dir.y;
         if (x >= 0 && x < this.grid[0].length && 
             y >= 0 && y < this.grid.length && 
             !this.grid[y][x].solid) {
           neighbors.push({x, y});
         }
       }
       return neighbors;
     }
   }
   ```

3. I `generateMap`-funktionen, skapa en pathfinding-grid:
   ```javascript
   function generateMap() {
     // ... befintlig kod ...
     
     // Skapa pathfinding grid
     window.pathfindingGrid = [];
     for (let y = 0; y < MAP_HEIGHT_TILES; y++) {
       const row = [];
       for (let x = 0; x < MAP_WIDTH_TILES; x++) {
         row.push({
           solid: mapGrid[y][x].solid,
           x,
           y
         });
       }
       pathfindingGrid.push(row);
     }
   }
   ```

4. Uppdatera fiendens AI:
   ```javascript
   class Enemy {
     // ... befintlig kod ...

     update() {
       // Uppdatera väg var 60:e frame
       if (this.pathUpdateCounter <= 0) {
         const startX = Math.floor((this.x + worldBounds.width/2) / TILE_SIZE);
         const startY = Math.floor((this.y + worldBounds.height/2) / TILE_SIZE);
         const endX = Math.floor((player.x + worldBounds.width/2) / TILE_SIZE);
         const endY = Math.floor((player.y + worldBounds.height/2) / TILE_SIZE);
         
         if (startX >= 0 && startX < MAP_WIDTH_TILES &&
             startY >= 0 && startY < MAP_HEIGHT_TILES &&
             endX >= 0 && endX < MAP_WIDTH_TILES &&
             endY >= 0 && endY < MAP_HEIGHT_TILES) {
           
           const astar = new AStar(window.pathfindingGrid);
           this.path = astar.search(
             window.pathfindingGrid[startY][startX],
             window.pathfindingGrid[endY][endX]
           );
         }
         this.pathUpdateCounter = 60;
       } else {
         this.pathUpdateCounter--;
       }

       // Följ vägen om den finns
       if (this.path && this.path.length > 0) {
         const target = this.path[0];
         const worldX = target.x * TILE_SIZE - worldBounds.width/2;
         const worldY = target.y * TILE_SIZE - worldBounds.height/2;
         
         const dx = worldX - this.x;
         const dy = worldY - this.y;
         const dist = Math.sqrt(dx * dx + dy * dy);
         
         if (dist < 5) {
           this.path.shift();
         } else {
           this.x += (dx / dist) * this.speed;
           this.y += (dy / dist) * this.speed;
         }
       } else {
         // Fallback till direkt förföljning
         const dx = player.x - this.x;
         const dy = player.y - this.y;
         const dist = Math.sqrt(dx * dx + dy * dy);
         if (dist > 0) {
           this.x += (dx / dist) * this.speed;
           this.y += (dy / dist) * this.speed;
         }
       }
     }
   }
   ```

## 2. Prestandaoptimering

### Mål: Förbättra FPS och minska minnesanvändning

**Steg:**
1. Implementera object pooling för vanliga objekt:
   ```javascript
   // object-pool.js
   class ObjectPool {
     constructor(createFn) {
       this.createFn = createFn;
       this.pool = [];
     }

     get(...args) {
       if (this.pool.length > 0) {
         const obj = this.pool.pop();
         this.createFn(obj, ...args);
         return obj;
       }
       return this.createFn(null, ...args);
     }

     release(obj) {
       this.pool.push(obj);
     }
   }

   // Skapa pooler
   const enemyPool = new ObjectPool((obj, x, y, size, color, speed, char, health) => {
     if (!obj) return new Enemy(x, y, size, color, speed, char, health);
     obj.x = x;
     obj.y = y;
     obj.size = size;
     obj.color = color;
     obj.speed = speed;
     obj.char = char;
     obj.health = health;
     obj.maxHealth = health;
     return obj;
   });

   const projectilePool = new ObjectPool((obj, x, y, radius, color, velocity, duration) => {
     if (!obj) return new Projectile(x, y, radius, color, velocity, duration);
     obj.x = x;
     obj.y = y;
     obj.radius = radius;
     obj.color = color;
     obj.velocity = velocity;
     obj.duration = duration;
     obj.life = 0;
     return obj;
   });

   const particlePool = new ObjectPool((obj, x, y, radius, color, velocity) => {
     if (!obj) return new Particle(x, y, radius, color, velocity);
     obj.x = x;
     obj.y = y;
     obj.radius = radius;
     obj.color = color;
     obj.velocity = velocity;
     obj.alpha = 1;
     return obj;
   });
   ```

2. Uppdatera spawn-funktioner att använda pooler:
   ```javascript
   function spawnEnemy() {
     // ... befintlig kod ...
     enemies.push(enemyPool.get(x, y, size, color, speed, char, health));
   }

   function performAttack() {
     // ... befintlig kod ...
     activeAttacks.push(projectilePool.get(
       player.x, player.y, 12, '#f97316', fbVelocity, 90
     ));
   }
   ```

3. Uppdatera destruction att använda pooler:
   ```javascript
   function handleCollisions() {
     // ... befintlig kod ...
     enemies.splice(eIndex, 1);
     enemyPool.release(enemy);
   }
   ```

4. Optimera rendering:
   ```javascript
   function animate() {
     // ... befintlig kod ...
     
     // Batch-rendera liknande objekt
     ctx.beginPath();
     xpGems.forEach(gem => {
       ctx.moveTo(gem.x + gem.radius, gem.y);
       ctx.arc(gem.x, gem.y, gem.radius, 0, Math.PI * 2);
     });
     ctx.fillStyle = '#fef08a';
     ctx.fill();
   }
   ```

## 3. Kollisionsdetektering

### Mål: Implementera mer effektiv kollisionsdetektering

**Steg:**
1. Skapa en Quadtree-klass:
   ```javascript
   // quadtree.js
   class Rectangle {
     constructor(x, y, w, h) {
       this.x = x;
       this.y = y;
       this.w = w;
       this.h = h;
     }

     contains(point) {
       return (
         point.x >= this.x &&
         point.x <= this.x + this.w &&
         point.y >= this.y &&
         point.y <= this.y + this.h
       );
     }

     intersects(range) {
       return !(
         range.x > this.x + this.w ||
         range.x + range.w < this.x ||
         range.y > this.y + this.h ||
         range.y + range.h < this.y
       );
     }
   }

   class QuadTree {
     constructor(boundary, capacity) {
       this.boundary = boundary;
       this.capacity = capacity;
       this.points = [];
       this.divided = false;
     }

     subdivide() {
       const x = this.boundary.x;
       const y = this.boundary.y;
       const w = this.boundary.w / 2;
       const h = this.boundary.h / 2;

       const nw = new Rectangle(x, y, w, h);
       const ne = new Rectangle(x + w, y, w, h);
       const sw = new Rectangle(x, y + h, w, h);
       const se = new Rectangle(x + w, y + h, w, h);

       this.northwest = new QuadTree(nw, this.capacity);
       this.northeast = new QuadTree(ne, this.capacity);
       this.southwest = new QuadTree(sw, this.capacity);
       this.southeast = new QuadTree(se, this.capacity);

       this.divided = true;
     }

     insert(point) {
       if (!this.boundary.contains(point)) return false;

       if (this.points.length < this.capacity) {
         this.points.push(point);
         return true;
       }

       if (!this.divided) this.subdivide();

       return (
         this.northwest.insert(point) ||
         this.northeast.insert(point) ||
         this.southwest.insert(point) ||
         this.southeast.insert(point)
       );
     }

     query(range, found = []) {
       if (!this.boundary.intersects(range)) return found;

       for (const p of this.points) {
         if (range.contains(p)) found.push(p);
       }

       if (this.divided) {
         this.northwest.query(range, found);
         this.northeast.query(range, found);
         this.southwest.query(range, found);
         this.southeast.query(range, found);
       }

       return found;
     }

     clear() {
       this.points = [];
       if (this.divided) {
         this.northwest.clear();
         this.northeast.clear();
         this.southwest.clear();
         this.southeast.clear();
       }
       this.divided = false;
     }
   }
   ```

2. Använd Quadtree för kollisionsdetektering:
   ```javascript
   // Skapa global quadtree
   let quadtree;

   function initQuadtree() {
     const boundary = new Rectangle(
       -worldBounds.width/2, 
       -worldBounds.height/2, 
       worldBounds.width, 
       worldBounds.height
     );
     quadtree = new QuadTree(boundary, 4);
   }

   function animate() {
     // ... befintlig kod ...
     
     // Uppdatera quadtree
     quadtree.clear();
     enemies.forEach(enemy => {
       enemy.quadTreeRect = new Rectangle(
         enemy.x - enemy.size/2,
         enemy.y - enemy.size/2,
         enemy.size,
         enemy.size
       );
       quadtree.insert(enemy.quadTreeRect);
     });
     
     // Använd quadtree för kollisionsdetektering
     const playerRect = new Rectangle(
       player.x - player.size/2,
       player.y - player.size/2,
       player.size,
       player.size
     );
     
     const nearbyEnemies = quadtree.query(playerRect);
     nearbyEnemies.forEach(enemyRect => {
       const enemy = enemies.find(e => e.quadTreeRect === enemyRect);
       // Hantera kollision...
     });
   }
   ```

## 4. UI-förbättringar

### Mål: Förbättra användarupplevelsen med intuitivt UI

**Steg:**
1. Förbättra karakterblad:
   ```javascript
   function renderCharacterSheet() {
     // ... befintlig kod ...
     
     // Lägg till drag and drop
     const slots = document.querySelectorAll('.inventory-slot');
     slots.forEach(slot => {
       slot.setAttribute('draggable', 'true');
       slot.addEventListener('dragstart', e => {
         e.dataTransfer.setData('text/plain', slot.dataset.itemInstance || '');
         e.dataTransfer.setData('slot-type', slot.dataset.slotType || '');
       });
       
       slot.addEventListener('dragover', e => {
         e.preventDefault();
         slot.classList.add('drag-over');
       });
       
       slot.addEventListener('dragleave', () => {
         slot.classList.remove('drag-over');
       });
       
       slot.addEventListener('drop', e => {
         e.preventDefault();
         slot.classList.remove('drag-over');
         const itemData = e.dataTransfer.getData('text/plain');
         const sourceSlotType = e.dataTransfer.getData('slot-type');
         
         if (itemData) {
           const itemInstance = JSON.parse(itemData);
           const targetSlotType = slot.dataset.slotType;
           
           // Hantera utrustning/inventory flytt
           // ... logik för att flytta föremål ...
         }
       });
     });
   }
   ```

2. Lägg till minimap:
   ```javascript
   function drawMinimap() {
     const size = 150;
     const scale = 0.1;
     const offsetX = 20;
     const offsetY = canvas.height - size - 20;
     
     // Bakgrund
     ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
     ctx.fillRect(offsetX, offsetY, size, size);
     
     // Rita kartan
     for (let y = 0; y < MAP_HEIGHT_TILES; y++) {
       for (let x = 0; x < MAP_WIDTH_TILES; x++) {
         if (x % 10 === 0 && y % 10 === 0) {
           const tile = mapGrid[y][x];
           ctx.fillStyle = tile.color;
           ctx.fillRect(
             offsetX + x * scale, 
             offsetY + y * scale, 
             1, 1
           );
         }
       }
     }
     
     // Rita spelaren
     const playerX = (player.x + worldBounds.width/2) * scale;
     const playerY = (player.y + worldBounds.height/2) * scale;
     ctx.fillStyle = '#fef08a';
     ctx.beginPath();
     ctx.arc(offsetX + playerX, offsetY + playerY, 3, 0, Math.PI * 2);
     ctx.fill();
     
     // Rita fiender
     enemies.forEach(enemy => {
       const enemyX = (enemy.x + worldBounds.width/2) * scale;
       const enemyY = (enemy.y + worldBounds.height/2) * scale;
       ctx.fillStyle = '#f87171';
       ctx.beginPath();
       ctx.arc(offsetX + enemyX, offsetY + enemyY, 2, 0, Math.PI * 2);
       ctx.fill();
     });
   }
   ```

3. Förbättra tooltips:
   ```javascript
   function showTooltip(slot) {
     // ... befintlig kod ...
     
     // Lägg till jämförelser
     if (slot.dataset.slotType) {
       const equippedItem = player.equipment[slot.dataset.slotType];
       if (equippedItem) {
         const equippedStats = { ...itemDB[equippedItem.baseId].baseStats, ...equippedItem.stats };
         const newStats = { ...baseItem.baseStats, ...item.stats };
         
         let comparison = '<div class="mt-2 text-sm">Jämförelse:</div>';
         for (const stat in newStats) {
           const diff = newStats[stat] - (equippedStats[stat] || 0);
           if (diff !== 0) {
             comparison += `<div class="${diff > 0 ? 'text-green-400' : 'text-red-400'}">${stat}: ${diff > 0 ? '+' : ''}${diff}</div>`;
           }
         }
         tooltipStats.innerHTML += comparison;
       }
     }
   }
   ```

4. Lägg till animerade effekter:
   ```javascript
   // level-up-screen.js
   function showLevelUpScreen() {
     // ... befintlig kod ...
     
     // Animerad text
     gsap.from('#level-up-screen h2', {
       duration: 0.5,
       scale: 0.5,
       opacity: 0,
       ease: 'back.out(1.7)'
     });
     
     // Animera upgrade-kort
     gsap.from('.upgrade-card', {
       duration: 0.3,
       y: 50,
       opacity: 0,
       stagger: 0.1
     });
   }
   ```

## Implementeringsplan

| Område           | Prioritering | Beräknad tid | Status     |
|------------------|-------------|--------------|------------|
| Pathfinding      | Högt        | 8 timmar     | Planerad   |
| Prestanda        | Mycket högt | 6 timmar     | Pågående   |
| Kollisioner      | Medel       | 5 timmar     | Planerad   |
| UI-förbättringar | Medel       | 7 timmar     | Planerad   |

**Total tid:** 26 timmar

Denna plan ger en strukturerad väg framåt för att förbättra Project Rune-Survive på alla fyra områden. Varje sektion är självständig men kan implementeras parallellt för effektiv utveckling.